package main

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"go/format"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"text/template"
)

const (
	InputPath  = "json"
	OutputPath = "."
)

type Const struct {
	Name string
	Data int64
}
type Consts []*Const

func (c Consts) Len() int {
	return len(c)
}
func (c Consts) Less(i, j int) bool {
	return c[i].Name < c[j].Name
}
func (c Consts) Swap(i, j int) {
	c[i], c[j] = c[j], c[i]
}

type Argument struct {
	Type     string
	Variable bool   `json:",omitempty"`
	UserObj  string `json:",omitempty"`
}

type Function struct {
	Arguments []*Argument `json:",omitempty"`
	Return    string      `json:",omitempty"`
	Name      string      `json:"-"`
}
type Functions []*Function

func (f Functions) Len() int {
	return len(f)
}
func (f Functions) Less(i, j int) bool {
	return f[i].Name < f[j].Name
}
func (f Functions) Swap(i, j int) {
	f[i], f[j] = f[j], f[i]
}

type FunctionRoot struct {
	Name       string `json:",omitempty"`
	Return     string `json:",omitempty"`
	RetUserObj string `json:",omitempty"`
}

type PropertyFunc struct {
	Get  *Function `json:",omitempty"`
	Set  *Function `json:",omitempty"`
	Name string    `json:"-"`
}
type PropertyFuncs []*PropertyFunc

func (pf PropertyFuncs) Len() int {
	return len(pf)
}
func (pf PropertyFuncs) Less(i, j int) bool {
	return pf[i].Name < pf[j].Name
}
func (pf PropertyFuncs) Swap(i, j int) {
	pf[i], pf[j] = pf[j], pf[i]
}

type FunctionMap struct {
	Property map[string]*PropertyFunc `json:",omitempty"`
	Method   map[string]*Function     `json:",omitempty"`
}

type FunctionList struct {
	Property []*PropertyFunc `json:"-"`
	Method   []*Function     `json:"-"`
}

type ObjectClass struct {
	FunctionMap
	TypeConst string `json:",omitempty"`
}

type ObjectClassStable struct {
	FunctionList
	TypeConst string `json:"-"`
	Objname   string `json:"-"`
}
type ObjectClassStables []*ObjectClassStable

func (ocs ObjectClassStables) Len() int {
	return len(ocs)
}
func (ocs ObjectClassStables) Less(i, j int) bool {
	return ocs[i].Objname < ocs[j].Objname
}
func (ocs ObjectClassStables) Swap(i, j int) {
	ocs[i], ocs[j] = ocs[j], ocs[i]
}

type Application struct {
	Package      string
	Object       string
	Const        map[string]int64
	RootFunction *FunctionRoot
	Basic        *ObjectClass
	Child        map[string]*ObjectClass
}

type PackageData struct {
	buf          *bytes.Buffer
	Package      string
	Object       string
	BasicObj     string
	RootFunction *FunctionRoot
	Const        []*Const
	Child        []*ObjectClassStable
}

type FunctionData struct {
	BasicObj string
	Obj      string
	FuncName string
	Arg      []*Argument
	OleFunc  string
	OleName  string
	RetType  string
	RetObj   string
}

var FunctionTempl = template.Must(template.ParseFiles("template/function.go"))
var PackageTempl = template.Must(template.ParseFiles("template/package.go"))
var FunctionPrefixMap = map[string]string{
	"GetProperty": "Get",
	"PutProperty": "Set",
	"CallMethod":  "",
}

func main() {
	var indir string
	var outroot string
	switch len(os.Args) {
	case 3:
		outroot = os.Args[2]
		fallthrough
	case 2:
		indir = os.Args[1]
	case 1, 0:
		indir = InputPath
		outroot = OutputPath
	default:
		log.Println("無効な引数です。")
		return
	}
	dir, err := ioutil.ReadDir(indir)
	if err != nil {
		log.Println(err)
		return
	}
	for _, it := range dir {
		name := it.Name()
		if filepath.Ext(name) == ".json" && it.IsDir() == false {
			err := Generate(filepath.Join(indir, name), outroot)
			if err != nil {
				log.Println(err)
			}
		}
	}
}

func Generate(in, outroot string) error {
	a, err := ReadJson(in)
	if err != nil {
		return err
	}
	if a.Package == "" {
		return errors.New("error:" + in + " - json => Packageが設定されてません。")
	}
	if a.RootFunction == nil {
		return errors.New("error:" + in + " - json => RootFunctionが設定されてません。")
	}
	a.RootFunction.RetUserObj = UserObjectDereference(a.RootFunction.Return)
	pd := PackageData{}
	pd.buf = &bytes.Buffer{}
	pd.Package = strings.ToLower(a.Package)
	pd.Object = a.Object
	pd.RootFunction = a.RootFunction
	pd.BasicObj = strings.Title(pd.Package)

	// 各関数の整列
	// mapそのままだと毎回生成結果が大きく変わるので、安定するデータ構造に変更する
	acon := []*Const{}
	for name, it := range a.Const {
		acon = append(acon, &Const{
			Name: name,
			Data: it,
		})
	}
	sort.Sort(Consts(acon))
	pd.Const = acon

	acsl := []*ObjectClassStable{}
	abs := Stable(a.Basic, pd.BasicObj)
	for obj, ac := range a.Child {
		acsl = append(acsl, Stable(ac, obj))
	}
	sort.Sort(ObjectClassStables(acsl))
	pd.Child = acsl

	// パッケージ書き出し
	var terr error
	fmt.Fprintf(pd.buf, "// Code generated by go-ole-msoffice/generetor (%s)\n", in)
	terr = PackageTempl.Execute(pd.buf, &pd)
	if terr != nil {
		log.Println(terr)
	}

	// 各関数の書き出し
	terr = pd.WriteModule(abs)
	if terr != nil {
		log.Println(terr)
	}
	for _, acs := range acsl {
		terr = pd.WriteModule(acs)
		if terr != nil {
			log.Println(terr)
		}
	}

	// ソースコード整形
	buf, err := format.Source(pd.buf.Bytes())
	if err != nil {
		return err
	}

	// 出力ディレクトリ生成
	outdir := filepath.Join(outroot, pd.Package)
	mkdirerr := MakeOutputDir(outdir)
	if mkdirerr != nil {
		return mkdirerr
	}
	// ファイルに書き出す
	werr := ioutil.WriteFile(filepath.Join(outdir, pd.Package+".go"), buf, 0666)
	if werr != nil {
		return werr
	}
	return nil
}

func Stable(oc *ObjectClass, ocname string) *ObjectClassStable {
	ocs := &ObjectClassStable{
		TypeConst: oc.TypeConst,
		Objname:   ocname,
	}
	for name, it := range oc.Property {
		it.Name = name
		if it.Get != nil {
			it.Get.Name = name
		}
		if it.Set != nil {
			it.Set.Name = name
		}
		ocs.Property = append(ocs.Property, it)
	}
	for name, it := range oc.Method {
		it.Name = name
		ocs.Method = append(ocs.Method, it)
	}
	sort.Sort(PropertyFuncs(ocs.Property))
	sort.Sort(Functions(ocs.Method))
	return ocs
}

func (pd *PackageData) WriteModule(ocs *ObjectClassStable) error {
	for _, it := range ocs.Property {
		if it.Get != nil {
			err := pd.WriteFunction(it.Get, ocs.Objname, "GetProperty")
			if err != nil {
				return err
			}
		}
		if it.Set != nil {
			err := pd.WriteFunction(it.Set, ocs.Objname, "PutProperty")
			if err != nil {
				return err
			}
		}
	}
	for _, it := range ocs.Method {
		err := pd.WriteFunction(it, ocs.Objname, "CallMethod")
		if err != nil {
			return err
		}
	}
	return nil
}

func (pd *PackageData) WriteFunction(f *Function, o, of string) error {
	pre := FunctionPrefixMap[of]
	for _, arg := range f.Arguments {
		arg.UserObj = UserObjectDereference(arg.Type)
	}
	fd := FunctionData{
		BasicObj: pd.BasicObj,
		Obj:      o,
		FuncName: pre + f.Name,
		Arg:      f.Arguments,
		OleFunc:  of,
		OleName:  f.Name,
		RetType:  f.Return,
		RetObj:   UserObjectDereference(f.Return),
	}
	return FunctionTempl.Execute(pd.buf, &fd)
}

func UserObjectDereference(t string) (ret string) {
	switch t {
	case "", "byte", "int", "int16", "uint16", "int32", "uint32", "int64", "uint64", "bool", "string", "time.Time", "interface{}", "*ole.VARIANT":
		ret = ""
	default:
		if t[0] == '*' {
			ret = t[1:]
		} else {
			ret = ""
		}
	}
	return
}

func MakeOutputDir(outdir string) error {
	if st, err := os.Stat(outdir); err == nil {
		if st.IsDir() == false {
			return errors.New("出力ディレクトリがディレクトリではないみたい。")
		}
	} else {
		mkdirerr := os.MkdirAll(outdir, 0666)
		if mkdirerr != nil {
			return mkdirerr
		}
	}
	return nil
}

func ReadJson(in string) (a *Application, reterr error) {
	fp, err := os.Open(in)
	if err != nil {
		return nil, err
	}
	defer fp.Close()
	a = &Application{}
	reterr = json.NewDecoder(fp).Decode(a)
	return
}
